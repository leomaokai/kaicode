# 算法套路

## 滑动窗口

滑动窗口模式是用于在给定数组或链表的特定窗口大小执行所需的操作,比如寻找包含所有1的最长子数组

从第一个元素开始滑动窗口并逐个元素地向右滑,一般情况下窗口大小不变

```markdown
# 可能需要滑动窗口的方法
- 问题的输入是一种线性数据结构,比如链表,数组,字符串
- 要求查找最长/最短的子字符串,子数组或所需的值
# 使用滑动窗口处理的常见问题
- 大小为 k 的子数组的最大和
- 带有 k 个不同字符的最长子字符串
- 寻找字符相同但排序不一样的字符串
```

## 双指针或迭代器

双指针以一前一后的模式在数据结构中迭代,直到一个或两个指针达到某种特定条件

```markdown
# 用于识别使用双指针的时机的方法:
- 处理排序数组并需要查找满足某些约束的一组元素的问题
- 数组中的元素集是配对,三元组甚至子数组
# 满足双指针模式的问题:
- 求一个排序数组的平方
- 求总和为0的三元组
- 比较包含回退的字符串
```

## 快慢指针

快慢指针使用两个在数组中以不同速度移动的指针.该方法在处理循环链表或数组时非常有用

通过以不同的速度进行移动两个指针(比如一个循环链表),两个指针注定会相遇.

```markdown
# 使用快慢指针的时机:
- 处理链表或数组中的循环问题
- 当需要知道特定元素的位置或链表的总长度时
# 与双指针的区别
- 有些情况不适合使用双指针,比如在不能反向移动的单链表中,使用快慢指针的一个案例是当你确定一个链表是否为回文
# 使用快慢指针解决的问题:
- 链表循环
- 回文链表
- 环形数组中的循环
```

## 合并区间

合并区间是一种处理重叠区间的有效技术

在很多涉及区间的问题中,既需要找到重叠的区间,也需要在这些区间重叠时合并它们

```markdown
# a,b两个区间的关联方式
- a,b完全不重叠
- a包含b
- b包含a
- a,b部分重叠
# 使用合并区间的时机:
- 要求得到仅含互斥区间的列表
- 术语重叠区间
# 合并区间的问题:
- 区间交叉
- 最大cpu负载
```

## 循环排序

循环排序模式一次会在数组上迭代一个数值,如果所迭代的当前数值不在正确的索引处,就将其与正确索引处的数值交换

```markdown
# 使用循环排序的时机:
- 涉及数值在给定范围内的排序数组的问题
- 如果问题要求在一个排序/旋转的数组中找到缺失值/重复值/最小值
# 循环排序的问题:
- 找到缺失值
- 找到最小的缺失的正数值
```

## 原地反转链表

原地完成一个任务,即使用已有的节点对象且不占用额外的内存

```markdown
# 使用时机:
- 要求不使用额外内存的前提下反转一个链表
# 解决问题:
- 反转一个子列表
- 反转每个K的元素的子列表
```

## 广度优先遍历

遍历一个数并使用一个队列来跟踪一个层级的所有节点,之后再跳转到下一个层级

任何涉及到以逐层级方式遍历的问题都可以使用这种方法

工作方式:将根节点入队,然后连续迭代直到队列为空.每次迭代时,移除队头,将移除对头之后,将其所有子节点插入到队列中

```markdown
# 使用BFS的时机:
- 要求逐层级方式遍历一个数
# 解决的问题
- 二叉树层级顺序遍历
- 之字形遍历
```

## 深度优先遍历

使用递归(或栈)来在遍历期间保持对所有之前节点的跟踪

```markdown
# BFS 工作方式从树的根部开始,如果这个节点不是一个叶节点,需要做两件事
- 决定现在处理当前的节点(pre-order),或是在处理两个节点之间(in-order),处理两个节点之后(post-order)
- 为当前节点的两个节点执行两次递归调用处理
# 使用 BFS 的时机
- 要求使用中序,前序,后序遍历一棵树
- 问题需要搜索其中节点更接近叶节点的东西
# 解决的问题
- 路径数量之和
- 一个和的所有路径
```

## Two Heaps

将一组元素分为两部分,一部分寻找最小值,一部分寻早最大值

该模式使用两个堆(heap):一个用于寻找最小元素的 Min Heap 和一个用于寻找最大元素的 Max Heap

```markdown
# 工作方式
- 先将前一半的数值存储到 Max Heap,寻早前一半的最大值,再将另一部分存储到 Min Heap,在第二部分中寻早最小值,在任何时候,当前数值列表的中间值都可以根据这两个 heap 的顶部元素计算得到
# 使用时机
- 在优先级队列,调度等场景使用
- 问题需要找到集合的最小/最大/中间元素
- 有时候可用于具有二叉树数据结构的问题
# 解决问题
- 查找一个数值流的中间值
```

## 子集

处理给定元素的排列和组合

子集模式描述了一种用于有效处理这些问题的 BFS 方法

```markdown
# 使用时机:
- 找到给定集合的组合或排列的问题
# 解决问题
- 带有重复项的子集
- 通过改变大小写的字符串排列
```

## 经过修改的二叉搜索

只要给定了排序数组,链表或矩阵,并要求寻找一个特定元素,最佳算法就是二叉搜索

```markdown
# 解决问题
- 与顺序无关的二叉搜索
- 在经过排序的无限数组中搜索
```

## 前K个元素

任何要求我们找到一个给定集合中前面的/最小的/最常出现的K的元素问题都在这一模式的范围内

跟踪 K 个元素的最佳数据结构是 Heap

```markdown
# 工作方式
- 根据问题的不同,将K个元素插入到 min-heap 或 max-heap 中
- 迭代处理剩余的数,如果找到一个比堆顶更大/更小的数,将堆顶数移除并插入新数
# 使用时机
- 要求寻找一个给定集合中前面的/最小的/最常出现的k的元素
- 要求对一个数值进行排序以找到一个确定元素
# 前k个元素模式的问题
- 前面的k个数
- 最常出现的k个数
```

## K路合并

k路合并解决涉及一组经过排序的数组的问题

当被给出k个经过排序的数组时,可以使用heap来有效地执行所有数组的所有元素的排序遍历,将每个数组的最小元素推送至 min heap 来获得整体最小值

获得整体最小值后,将来自同一个数组的下一个元素推送至heap

```markdown
# 使用时机
- 具有排序数组,链表或矩阵的问题
- 如果问题要求合并排序的链表,找到一个排序列表中的最小元素
# 解决问题
- 合并k个排序的列表
- 找到和最大的k个配对
```

## 拓扑排序

拓扑排序可用于寻找互相依赖的元素的线性排序

比如,如果事件B依赖于事件A,那么A的拓扑排序位于B之前

```markdown
# 使用时机
- 处理无向有环图的问题
- 要求以排序顺序更新所有对象
- 有一类遵循特定顺序的对象
# 解决问题
- 任务调度
- 一个树的最小高度
```



